## kafka brokers
##
## value：host1:port1,host2:port2
bridge.kafka.broker = localhost:9092

## kafka topic partition
##
## value：number
bridge.kafka.partition = 1

## kafka client config
##
## value: Option: OptionValue
## atom_configs: option value type need to be atom
## integer_configs: option value type need to be integer
## string_configs: option value type need to be string  [emqx.kafka.bridge.client.string]

## auto_start_producers (optional, default=false)
##     If true, brod client will spawn a producer automatically when
##     user is trying to call `produce' but did not call `brod:start_producer'
##     explicitly. Can be useful for applications which don't know beforehand
##     which topics they will be working with.

## allow_topic_auto_creation (optional, default=true)
##     By default, brod respects what is configured in broker about
##     topic auto-creation. i.e. whatever `auto.create.topics.enable'
##     is set in broker configuration.

## query_api_versions (optional, default=true)
##     Must be set to false to work with kafka versions prior to 0.10,
##     When set to `true', at connection start, brod will send a query request
##     to get the broker supported API version ranges.
##     When set to 'false', brod will alway use the lowest supported API version
##     when sending requests to kafka.

## reconnect_cool_down_seconds (optional, default=1):
##  	Delay this configured number of seconds before retrying to
##  	estabilish a new connection to the kafka partition leader.

## get_metadata_timeout_seconds(optional, default=5):
## 		Return `{error, timeout}' from `brod_client:get_xxx' calls if
##      responses for APIs such as `metadata', `find_coordinator'
##      is not received in time.

## restart_delay_seconds (optional, default=10):
##  	How much time to wait between attempts to restart brod_client
##      process when it crashes

bridge.kafka.payload_encoding = plain

# bridge.kafka.rule.client.connect.1 = {"topic": "emqx.events.client_connect"}
# bridge.kafka.rule.client.connack.1 = {"topic": "emqx.events.client_connack"}
bridge.kafka.rule.client.connected.1 = {"topic": "emqx.events.client_connected"}
bridge.kafka.rule.client.disconnected.1 = {"topic": "emqx.events.disconnected"}
# bridge.kafka.rule.client.subscribe.1 = {"topic": "emqx.events.client_subscribe"}
# bridge.kafka.rule.client.unsubscribe.1 = {"topic": "emqx.events.unsubscribe"}
# bridge.kafka.rule.session.subscribed.1 = {"topic": "emqx.events.subscribed"}
# bridge.kafka.rule.session.unsubscribed.1 = {"topic": "emqx.events.unsubscribed"}
# bridge.kafka.rule.session.terminated.1 = {"topic": "emqx.events.terminated"}
bridge.kafka.rule.message.publish.1 = {"topic": "emqx.events.publish"}
# bridge.kafka.rule.message.delivered.1 = {"topic": "emqx.events.delivered"}
# bridge.kafka.rule.message.acked.1 = {"topic": "emqx.events.acked"}
